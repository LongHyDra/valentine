<!doctype html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Love Universe</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #03040a;
      --card: rgba(8, 12, 30, 0.72);
      --line: rgba(255, 255, 255, 0.24);
      --text: #f8f9ff;
      --muted: #dde3f2;
      --pink: #ff4f90;
      --blue: #7ce8ff;
      --gold: #ffd27e;
    }
    * { box-sizing: border-box; }
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      overflow: hidden;
      background:
        radial-gradient(circle at 15% 12%, #1c2350 0, rgba(18, 24, 56, 0.8) 30%, transparent 60%),
        radial-gradient(circle at 84% 9%, #3a0f2d 0, rgba(42, 12, 34, 0.75) 28%, transparent 56%),
        linear-gradient(160deg, #050816 0%, #03040a 55%, #020209 100%);
      color: var(--text);
      font-family: "Space Grotesk", system-ui, sans-serif;
    }
    #scene {
      position: fixed;
      inset: 0;
      z-index: 0;
    }
    .scene-glow {
      position: fixed;
      inset: 0;
      z-index: 1;
      pointer-events: none;
      background:
        radial-gradient(circle at 20% 76%, rgba(124, 232, 255, 0.12), transparent 38%),
        radial-gradient(circle at 80% 18%, rgba(255, 79, 144, 0.16), transparent 42%),
        radial-gradient(circle at 50% 48%, rgba(255, 210, 126, 0.06), transparent 45%);
      mix-blend-mode: screen;
      animation: auraShift 12s ease-in-out infinite alternate;
    }
    @keyframes auraShift {
      from { opacity: 0.72; transform: translateY(-6px) scale(1); }
      to { opacity: 1; transform: translateY(8px) scale(1.03); }
    }
    .panel {
      position: fixed;
      z-index: 4;
      left: 16px;
      top: 16px;
      max-width: min(500px, calc(100vw - 32px));
      padding: 14px 16px;
      border-radius: 14px;
      background: linear-gradient(140deg, rgba(16, 20, 42, 0.9), rgba(9, 12, 30, 0.78));
      border: 1px solid var(--line);
      box-shadow:
        0 18px 38px rgba(0, 0, 0, 0.42),
        0 0 35px rgba(255, 79, 144, 0.14),
        inset 0 1px 0 rgba(255, 255, 255, 0.16);
      backdrop-filter: blur(10px);
    }
    .tag {
      display: inline-flex;
      align-items: center;
      gap: 7px;
      border-radius: 999px;
      padding: 5px 10px;
      font-size: 12px;
      font-weight: 700;
      letter-spacing: 0.4px;
      text-transform: uppercase;
      color: #fff5fa;
      background: linear-gradient(120deg, rgba(255, 79, 144, 0.4), rgba(124, 232, 255, 0.2));
      box-shadow: 0 0 18px rgba(255, 79, 144, 0.24);
      margin-bottom: 8px;
    }
    .panel h1 {
      margin: 0;
      font-size: clamp(24px, 4.5vw, 36px);
      line-height: 1.1;
      letter-spacing: 0.3px;
      background: linear-gradient(140deg, #ffffff 0%, #ffd7e8 45%, #8cecff 100%);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-shadow: 0 0 12px rgba(255, 255, 255, 0.18);
    }
    .panel p {
      margin: 8px 0 0;
      color: var(--muted);
      font-size: clamp(12px, 2vw, 14px);
      line-height: 1.5;
    }
    .hint {
      position: fixed;
      right: 16px;
      top: 16px;
      z-index: 4;
      border-radius: 999px;
      padding: 8px 12px;
      background: linear-gradient(120deg, rgba(13, 18, 40, 0.9), rgba(10, 14, 34, 0.74));
      border: 1px solid var(--line);
      color: #ffe8f2;
      font-size: 12px;
      letter-spacing: 0.3px;
      backdrop-filter: blur(8px);
      box-shadow: 0 0 16px rgba(124, 232, 255, 0.2);
    }
    .actions {
      position: fixed;
      right: 16px;
      bottom: 16px;
      z-index: 4;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 12px;
      border-radius: 12px;
      background: linear-gradient(120deg, rgba(12, 18, 42, 0.9), rgba(12, 16, 36, 0.75));
      border: 1px solid var(--line);
      box-shadow: 0 14px 30px rgba(0, 0, 0, 0.36), 0 0 20px rgba(255, 79, 144, 0.18);
      backdrop-filter: blur(10px);
    }
    .actions button {
      border: 0;
      border-radius: 10px;
      padding: 7px 11px;
      font-family: inherit;
      font-size: 12px;
      color: #fff;
      background: linear-gradient(120deg, rgba(255, 79, 144, 0.32), rgba(124, 232, 255, 0.16));
      cursor: pointer;
      transition: transform 0.15s ease, background 0.2s ease;
    }
    .actions button:hover {
      transform: translateY(-1px);
      background: linear-gradient(120deg, rgba(255, 79, 144, 0.46), rgba(124, 232, 255, 0.2));
    }
    .dot {
      width: 9px;
      height: 9px;
      border-radius: 50%;
      background: #45f2b4;
      box-shadow: 0 0 10px #45f2b4;
      animation: pulse 1.2s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% { transform: scale(0.84); opacity: 0.8; }
      50% { transform: scale(1.2); opacity: 1; }
    }
    #status {
      position: fixed;
      left: 16px;
      bottom: 16px;
      z-index: 5;
      border-radius: 12px;
      padding: 8px 11px;
      font-size: 12px;
      color: #ffe8f2;
      background: rgba(5, 8, 22, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.13);
      backdrop-filter: blur(8px);
      box-shadow: 0 0 16px rgba(124, 232, 255, 0.12);
    }
    @media (max-width: 760px) {
      .hint { display: none; }
      .panel { max-width: calc(100vw - 20px); left: 10px; top: 10px; }
      .actions { right: 10px; bottom: 10px; }
      #status { left: 10px; bottom: 10px; }
    }
  </style>
</head>
<body>
  <div id="scene"></div>
  <div class="scene-glow"></div>
  <section class="panel">
    <div class="tag">Love Universe</div>
    <h1>CHAO MUNG DEN VU TRU TINH YEU</h1>
    <p>Anh dua em toi vu tru cua chung ta roi ne. Minh cung ngam lai nhung ky niem dep nhat nha em yeu.</p>
  </section>

  <div class="hint">Drag de xoay - Scroll de zoom</div>

  <div class="actions">
    <span class="dot"></span>
    <button id="musicToggle">BAT NHAC</button>
    <button id="backBtn">QUAY LAI</button>
    <audio id="bgMusic" loop preload="auto"></audio>
  </div>

  <div id="status">DANG TAI VU TRU...</div>

  <script>
    const statusBox = document.getElementById("status");
    const musicToggle = document.getElementById("musicToggle");
    const bgMusic = document.getElementById("bgMusic");
    const isMobile = window.innerWidth < 768;

    const scriptChains = [
      [
        "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js",
        "https://unpkg.com/three@0.160.0/build/three.min.js"
      ],
      [
        "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js",
        "https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js",
        "./OrbitControls.js"
      ]
    ];

    const musicSources = [
      "https://files.catbox.moe/5iyzb4.mp3",
      "https://files.catbox.moe/5iyzb4.mp3",
      "https://cdn.pixabay.com/download/audio/2022/03/15/audio_2f48e5072e.mp3?filename=romantic-ambient-11268.mp3"
    ];
    const shouldAutoPlayMusic =
      new URLSearchParams(window.location.search).get("autoplay") === "1" ||
      sessionStorage.getItem("autoPlayUniverseMusic") === "1";
    let musicSourceIndex = 0;

    function loadWithFallback(urls, onDone, idx = 0) {
      if (idx >= urls.length) {
        statusBox.textContent = "Khong tai duoc thu vien 3D.";
        return;
      }
      const s = document.createElement("script");
      s.src = urls[idx];
      s.onload = onDone;
      s.onerror = () => loadWithFallback(urls, onDone, idx + 1);
      document.head.appendChild(s);
    }

    function boot() {
      if (typeof THREE === "undefined") {
        loadWithFallback(scriptChains[0], () => loadWithFallback(scriptChains[1], initUniverse));
      } else if (typeof THREE.OrbitControls === "undefined") {
        loadWithFallback(scriptChains[1], initUniverse);
      } else {
        initUniverse();
      }
    }

    function setMusicButton(playing) {
      musicToggle.textContent = playing ? "ðŸ”Š TAT NHAC" : "ðŸŽµ BAT NHAC";
    }

    function applyMusicSource(index) {
      musicSourceIndex = index;
      bgMusic.src = musicSources[index];
      bgMusic.load();
    }

    bgMusic.addEventListener("error", () => {
      if (musicSourceIndex < musicSources.length - 1) {
        applyMusicSource(musicSourceIndex + 1);
      }
    });

    bgMusic.addEventListener("canplaythrough", async () => {
      if (!shouldAutoPlayMusic) return;
      if (!bgMusic.paused) return;
      try {
        await bgMusic.play();
        setMusicButton(true);
      } catch (_) {
        setMusicButton(false);
      }
    });

    musicToggle.addEventListener("click", async () => {
      if (!bgMusic.src) applyMusicSource(0);
      if (bgMusic.paused) {
        try {
          await bgMusic.play();
          setMusicButton(true);
        } catch (_) {}
      } else {
        bgMusic.pause();
        setMusicButton(false);
      }
    });

    document.getElementById("backBtn").addEventListener("click", () => {
      window.location.href = "index.html";
    });

    applyMusicSource(0);
    setMusicButton(false);
    if (shouldAutoPlayMusic) {
      sessionStorage.removeItem("autoPlayUniverseMusic");
      setTimeout(async () => {
        try {
          await bgMusic.play();
          setMusicButton(true);
        } catch (_) {
          setMusicButton(false);
        }
      }, 160);
      document.addEventListener("pointerdown", async () => {
        if (!bgMusic.paused) return;
        try {
          await bgMusic.play();
          setMusicButton(true);
        } catch (_) {}
      }, { once: true });
    }

    function initUniverse() {
      statusBox.textContent = "Dang khoi tao...";

      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x02040d, 0.00155);

      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 3000);
      camera.position.set(0, 45, 228);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.4 : 1.8));
      renderer.setClearColor(0x03050f, 1);
      document.getElementById("scene").appendChild(renderer.domElement);

      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.5;

      scene.add(new THREE.AmbientLight(0xffd6eb, 0.5));
      const centerLight = new THREE.PointLight(0xff5ca6, 2.05, 760);
      centerLight.position.set(0, 0, 0);
      scene.add(centerLight);
      const sideLightA = new THREE.PointLight(0x7ce8ff, 0.85, 980);
      sideLightA.position.set(190, 140, 260);
      scene.add(sideLightA);
      const sideLightB = new THREE.PointLight(0xff8bbd, 0.72, 980);
      sideLightB.position.set(-210, -100, -180);
      scene.add(sideLightB);

      const core = createCoreParticles(isMobile ? 10000 : 16000, 40);
      scene.add(core);

      const ringGroup = new THREE.Group();
      scene.add(ringGroup);
      createRingCloud(isMobile ? 7800 : 13000, 72, 210, 38, ringGroup, "#ff6aa7", "#fff4fd");
      createRingCloud(isMobile ? 6200 : 10500, 56, 165, 18, ringGroup, "#ffe9f4", "#9eeeff");
      createRingCloud(isMobile ? 4200 : 7800, 105, 245, 46, ringGroup, "#8feaff", "#ffffff");

      const stars = createStarField(
        isMobile ? 4200 : 7800,
        980,
        "#dff6ff",
        isMobile ? 1.0 : 1.25,
        0.95
      );
      scene.add(stars);
      const starsFar = createStarField(
        isMobile ? 1600 : 3200,
        1400,
        "#ffdff0",
        isMobile ? 0.8 : 0.95,
        0.55
      );
      scene.add(starsFar);

      const photos = new THREE.Group();
      scene.add(photos);
      const photoList = Array.from({ length: 11 }, (_, i) => `anh${i + 1}.jpg`);
      const PHOTO_CLONES_PER_IMAGE = isMobile ? 5 : 8;
      photoList.forEach((src) => addPhoto(src, "", PHOTO_CLONES_PER_IMAGE));

      const meteors = createMeteors(isMobile ? 16 : 30);

      function createCoreParticles(count, radius) {
        const positions = new Float32Array(count * 3);
        const colors = new Float32Array(count * 3);
        const cHot = new THREE.Color("#ff2d2d");
        const cMid = new THREE.Color("#ff8e8e");
        const cDark = new THREE.Color("#8d0f0f");

        for (let i = 0; i < count; i += 1) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          const r = radius * Math.cbrt(Math.random());
          const x = r * Math.sin(phi) * Math.cos(theta);
          const y = r * Math.sin(phi) * Math.sin(theta);
          const z = r * Math.cos(phi);

          positions[i * 3] = x;
          positions[i * 3 + 1] = y;
          positions[i * 3 + 2] = z;

          const mix = cHot.clone().lerp(cMid, Math.random() * 0.5).lerp(cDark, (r / radius) * 0.52);
          colors[i * 3] = mix.r;
          colors[i * 3 + 1] = mix.g;
          colors[i * 3 + 2] = mix.b;
        }

        const g = new THREE.BufferGeometry();
        g.setAttribute("position", new THREE.BufferAttribute(positions, 3));
        g.setAttribute("color", new THREE.BufferAttribute(colors, 3));
        const m = new THREE.PointsMaterial({
          size: isMobile ? 1.2 : 1.45,
          transparent: true,
          opacity: 0.98,
          vertexColors: true,
          depthWrite: false,
          blending: THREE.AdditiveBlending
        });
        return new THREE.Points(g, m);
      }

      function createRingCloud(count, rMin, rMax, thickness, target, c1Hex, c2Hex) {
        const positions = new Float32Array(count * 3);
        const colors = new Float32Array(count * 3);
        const c1 = new THREE.Color(c1Hex);
        const c2 = new THREE.Color(c2Hex);

        for (let i = 0; i < count; i += 1) {
          const radius = THREE.MathUtils.randFloat(rMin, rMax);
          const angle = Math.random() * Math.PI * 2;
          const y = THREE.MathUtils.randFloatSpread(thickness);
          positions[i * 3] = Math.cos(angle) * radius;
          positions[i * 3 + 1] = y * 0.4;
          positions[i * 3 + 2] = Math.sin(angle) * radius;

          const t = (radius - rMin) / (rMax - rMin);
          const mix = c1.clone().lerp(c2, t);
          colors[i * 3] = mix.r;
          colors[i * 3 + 1] = mix.g;
          colors[i * 3 + 2] = mix.b;
        }

        const g = new THREE.BufferGeometry();
        g.setAttribute("position", new THREE.BufferAttribute(positions, 3));
        g.setAttribute("color", new THREE.BufferAttribute(colors, 3));
        const m = new THREE.PointsMaterial({
          size: isMobile ? 1.28 : 1.65,
          transparent: true,
          opacity: 0.97,
          depthWrite: false,
          vertexColors: true
        });
        const points = new THREE.Points(g, m);
        points.rotation.x = THREE.MathUtils.degToRad(12);
        target.add(points);
      }

      function createStarField(count, distance, colorHex, size, opacity) {
        const positions = new Float32Array(count * 3);
        for (let i = 0; i < count; i += 1) {
          positions[i * 3] = THREE.MathUtils.randFloatSpread(distance);
          positions[i * 3 + 1] = THREE.MathUtils.randFloatSpread(distance);
          positions[i * 3 + 2] = THREE.MathUtils.randFloatSpread(distance);
        }
        const g = new THREE.BufferGeometry();
        g.setAttribute("position", new THREE.BufferAttribute(positions, 3));
        const m = new THREE.PointsMaterial({
          color: colorHex,
          size: size,
          transparent: true,
          opacity: opacity,
          depthWrite: false
        });
        return new THREE.Points(g, m);
      }

      function addPhoto(src, fallback, count = 1) {
        const loader = new THREE.TextureLoader();
        if (loader.setCrossOrigin) loader.setCrossOrigin("anonymous");

        const onTexture = (texture) => {
          texture.colorSpace = THREE.SRGBColorSpace;
          const photoSize = isMobile ? 13 : 20;
          const g = new THREE.PlaneGeometry(photoSize, photoSize);
          const m = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide });
          for (let i = 0; i < count; i += 1) {
            const mesh = new THREE.Mesh(g, m);
            randomizePhoto(mesh);
            photos.add(mesh);
          }
        };

        loader.load(src, onTexture, undefined, () => {
          if (!fallback) return;
          loader.load(fallback, onTexture, undefined, () => {});
        });
      }

      function randomizePhoto(mesh) {
        const radius = THREE.MathUtils.randFloat(125, 295);
        const angle = Math.random() * Math.PI * 2;
        const y = THREE.MathUtils.randFloatSpread(105);
        mesh.position.set(Math.cos(angle) * radius, y, Math.sin(angle) * radius);
        mesh.lookAt(0, 0, 0);
        mesh.userData.radius = radius;
        mesh.userData.angle = angle;
        mesh.userData.speed = THREE.MathUtils.randFloat(0.0006, 0.0015);
      }

      function createMeteors(count) {
        const result = [];
        const baseDir = new THREE.Vector3(-1, -0.21, -0.1).normalize();

        function reset(m) {
          m.speed = THREE.MathUtils.randFloat(1.1, 2.2);
          m.tail = THREE.MathUtils.randFloat(18, 34);
          m.head.position.set(
            THREE.MathUtils.randFloat(220, 760),
            THREE.MathUtils.randFloat(160, 340),
            THREE.MathUtils.randFloat(-320, 320)
          );
          m.dir.copy(baseDir);
          m.dir.x += THREE.MathUtils.randFloat(-0.08, 0.08);
          m.dir.y += THREE.MathUtils.randFloat(-0.04, 0.02);
          m.dir.z += THREE.MathUtils.randFloat(-0.08, 0.08);
          m.dir.normalize();
          updateTrail(m);
        }

        function updateTrail(m) {
          const p = m.head.position;
          m.arr[0] = p.x;
          m.arr[1] = p.y;
          m.arr[2] = p.z;
          m.arr[3] = p.x - m.dir.x * m.tail;
          m.arr[4] = p.y - m.dir.y * m.tail;
          m.arr[5] = p.z - m.dir.z * m.tail;
          m.line.geometry.attributes.position.needsUpdate = true;
        }

        for (let i = 0; i < count; i += 1) {
          const head = new THREE.Mesh(
            new THREE.SphereGeometry(0.95, 10, 10),
            new THREE.MeshBasicMaterial({
              color: 0x4df0ff,
              transparent: true,
              opacity: 0.95,
              blending: THREE.AdditiveBlending,
              depthWrite: false
            })
          );
          const arr = new Float32Array(6);
          const geo = new THREE.BufferGeometry();
          geo.setAttribute("position", new THREE.BufferAttribute(arr, 3));
          const line = new THREE.Line(
            geo,
            new THREE.LineBasicMaterial({
              color: 0x9ef6ff,
              transparent: true,
              opacity: 0.8,
              blending: THREE.AdditiveBlending,
              depthWrite: false
            })
          );
          scene.add(head);
          scene.add(line);
          const meteor = { head, line, arr, dir: new THREE.Vector3(), tail: 22, speed: 1.4 };
          reset(meteor);
          meteor.head.position.addScaledVector(meteor.dir, -THREE.MathUtils.randFloat(0, 520));
          result.push(meteor);
        }

        return {
          update() {
            for (let i = 0; i < result.length; i += 1) {
              const m = result[i];
              m.head.position.x += m.dir.x * m.speed;
              m.head.position.y += m.dir.y * m.speed;
              m.head.position.z += m.dir.z * m.speed;
              updateTrail(m);
              if (m.head.position.x < -780 || m.head.position.y < -130 || m.head.position.z < -520 || m.head.position.z > 520) {
                reset(m);
              }
            }
          }
        };
      }

      function animate() {
        requestAnimationFrame(animate);
        const t = performance.now() * 0.001;
        const pulse = 1 + Math.sin(t * 2.5) * 0.032;
        core.scale.setScalar(pulse);
        core.rotation.y += 0.00135;
        ringGroup.rotation.y += 0.00105;
        stars.rotation.y += 0.00022;
        starsFar.rotation.y -= 0.00008;
        centerLight.intensity = 1.55 + (Math.sin(t * 2.5) + 1) * 0.38;
        sideLightA.intensity = 0.62 + (Math.sin(t * 1.8 + 0.6) + 1) * 0.24;
        sideLightB.intensity = 0.54 + (Math.sin(t * 1.4 + 2.1) + 1) * 0.19;
        meteors.update();

        photos.children.forEach((mesh) => {
          mesh.userData.angle += mesh.userData.speed;
          const r = mesh.userData.radius;
          mesh.position.x = Math.cos(mesh.userData.angle) * r;
          mesh.position.z = Math.sin(mesh.userData.angle) * r;
          mesh.lookAt(0, 0, 0);
        });

        controls.update();
        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      statusBox.remove();
    }

    boot();
  </script>
</body>
</html>

